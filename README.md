![header](https://capsule-render.vercel.app/api?type=waving&color=auto&height=300&section=header&text=블로그%20서버%20만들기&fontSize=70)

# Spring 개인과제

### 🏁 Goal:  회원가입, 로그인, 댓글 작성/조회/수정/삭제 기능이 추가된 나만의 블로그 백엔드 서버 만들기

<aside>
☝ **추가된 요구사항을 구현해 보세요!**

</aside>

1. 회원 가입 API
   - username, password를 Client에서 전달받기
   - username은  `최소 4자 이상, 10자 이하이며 알파벳 소문자(a~z), 숫자(0~9)`로 구성되어야 한다.
   - password는  `최소 8자 이상, 15자 이하이며 알파벳 대소문자(a~z, A~Z), 숫자(0~9), 특수문자`로 구성되어야 한다.
   - DB에 중복된 username이 없다면 회원을 저장하고 Client 로 성공했다는 메시지, 상태코드 반환하기
   - 회원 권한 부여하기 (ADMIN, USER) - ADMIN 회원은 모든 게시글, 댓글 수정 / 삭제 가능


2. 로그인 API
   - username, password를 Client에서 전달받기
   - DB에서 username을 사용하여 저장된 회원의 유무를 확인하고 있다면 password 비교하기
   - 로그인 성공 시, 로그인에 성공한 유저의 정보와 JWT를 활용하여 토큰을 발급하고,
     발급한 토큰을 Header에 추가하고 성공했다는 메시지, 상태코드 와 함께 Client에 반환하기
3. 댓글 작성 API
   - 토큰을 검사하여, 유효한 토큰일 경우에만 댓글 작성 가능
   - 선택한 게시글의 DB 저장 유무를 확인하기
   - 선택한 게시글이 있다면 댓글을 등록하고 등록된 댓글 반환하기
4. 댓글 수정 API
   - 토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 수정 가능
   - 선택한 댓글의 DB 저장 유무를 확인하기
   - 선택한 댓글이 있다면 댓글 수정하고 수정된 댓글 반환하기
5. 댓글 삭제 API
   - 토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 삭제 가능
   - 선택한 댓글의 DB 저장 유무를 확인하기
   - 선택한 댓글이 있다면 댓글 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기
6. 예외 처리
   - 토큰이 필요한 API 요청에서 토큰을 전달하지 않았거나 정상 토큰이 아닐 때는 "토큰이 유효하지 않습니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 토큰이 있고, 유효한 토큰이지만 해당 사용자가 작성한 게시글/댓글이 아닌 경우에는 “작성자만 삭제/수정할 수 있습니다.”라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - DB에 이미 존재하는 username으로 회원가입을 요청한 경우 "중복된 username 입니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 로그인 시, 전달된 username과 password 중 맞지 않는 정보가 있다면 "회원을 찾을 수 없습니다."라는 에러메시지와 statusCode: 400을 Client에 반환하기

<aside>
✌️ **요구사항에 맞게 수정해 보세요!**

</aside>

1. 전체 게시글 목록 조회 API
   - 제목, 작성자명(username), 작성 내용, 작성 날짜를 조회하기
   - 작성 날짜 기준 내림차순으로 정렬하기
   - 각각의 게시글에 등록된 모든 댓글을 게시글과 같이 Client에 반환하기
   - 댓글은 작성 날짜 기준 내림차순으로 정렬하기
2. 게시글 작성 API
   - 토큰을 검사하여, 유효한 토큰일 경우에만 게시글 작성 가능
   - 제목, 작성자명(username), 작성 내용을 저장하고
   - 저장된 게시글을 Client 로 반환하기
3. 선택한 게시글 조회 API
   - 선택한 게시글의 제목, 작성자명(username), 작성 날짜, 작성 내용을 조회하기
     (검색 기능이 아닙니다. 간단한 게시글 조회만 구현해주세요.)
   - 선택한 게시글에 등록된 모든 댓글을 선택한 게시글과 같이 Client에 반환하기
   - 댓글은 작성 날짜 기준 내림차순으로 정렬하기
4. 선택한 게시글 수정 API
   - ~~수정을 요청할 때 수정할 데이터와 비밀번호를 같이 보내서 서버에서 비밀번호 일치 여부를 확인 한 후~~
   - 토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 수정 가능
   - 제목, 작성 내용을 수정하고 수정된 게시글을 Client 로 반환하기
5. 선택한 게시글 삭제 API
   - ~~삭제를 요청할 때 비밀번호를 같이 보내서 서버에서 비밀번호 일치 여부를 확인 한 후~~
   - 토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 삭제 가능
   - 선택한 게시글을 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기

## API 명세서

![lv3api](https://github.com/itsinseo/springBlog_lv3_complete/assets/87530331/753133ee-4270-45ed-aefb-0b9afffe3bbe)


## ERD

![lv3_updated](https://github.com/itsinseo/springBlog_lv3_incomplete/assets/87530331/b831ec73-9725-4d94-bd4a-9d3eb8a1e58c)

## Why?
Q1. 처음 설계한 API 명세서에 변경사항이 있었나요?
   변경 되었다면 어떤 점 때문 일까요? 첫 설계의 중요성에 대해 작성해 주세요!

A1. 토큰을 활용하는 방식에 있어서 메서드 세부 로직과 매개변수 등이 조금씩 변경되었습니다.
   첫 설계를 제대로 하지 않으면 Controller, Service, Repository 모두에서 매개변수, 리턴 타입, 검증 로직 등을 하나씩 수정해야 하기 때문에 첫 설계가 중요한 것 같습니다.

<br>

Q2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되셨나요?

A2. Entity 연관 관계를 다이어그램을 통해 더 쉽게 이해하고 기억할 수 있었습니다.

<br>

Q3. JWT를 사용하여 인증/인가를 구현 했을 때의 장점은 무엇일까요?

A3. SecretKey만 있으면 인증/인가가 가능하다는 점이 장점인 것 같습니다.

<br>

Q4. 반대로 JWT를 사용한 인증/인가의 한계점은 무엇일까요?

A4. SecretKey가 노출되면 정보 조작이 가능하다는 점이 한계점인 것 같습니다.

<br>

Q5. 댓글이 달려있는 게시글을 삭제하려고 할 때 무슨 문제가 발생할까요? JPA가 아닌 Database 테이블 관점에서 해결방법이 무엇일까요?

A5. 댓글은 게시글을 참조하고 있는 상태일 텐데 참조한 데이터의 원본이 없어져 버리는 문제가 발생할 것 같습니다.
   게시글을 삭제할 때, 해당 게시글을 참조하는 댓글들을 같이 삭제하는 것이 해결방법이라고 생각합니다.

<br>

Q6. 5번과 같은 문제가 발생했을 때 JPA에서는 어떻게 해결할 수 있을까요?
   
A6. 연관관계가 있는 Entity는 CascadeType.REMOVE 속성을 추가해서 문제 발생을 막을 수 있을 것 같습니다.

<br>

Q7. IoC / DI 에 대해 간략하게 설명해 주세요!
   
A7. 직역하면 각각 제어의 역전 / 의존성 주입입니다.
   제어의 역전이란 말 그대로 개발자가 직접 메서드나 객체를 제어하는 것이 아니라 라이브러리/프레임워크 등이 제어 권한을 갖는 방식입니다.
   의존성 주입이란 어떤 클래스/객체 A가 다른 클래스나 객체를 사용하려고 할 때, A가 직접 객체를 생성하는 것이 아니라 사용될 객체를 미리 생성하여 A에 넣어주는 기법 같은 것으로 알고 있습니다. 의존성 주입은 IoC 의 구현 방법 중 하나라고 알고 있습니다.
   IoC / DI 의 장점은 전체적인 흐름/제어는 프레임워크에 맡기고 세부적인 로직, 사용될 메서드와 객체를 설계하고 구현하는 것에 집중할 수 있다는 것이 장점인 것 같습니다.
